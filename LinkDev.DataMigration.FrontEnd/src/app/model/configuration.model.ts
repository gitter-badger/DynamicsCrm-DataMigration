/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v11.12.13.0 (NJsonSchema v9.10.14.0 (Newtonsoft.Json v9.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming



export class Record implements IRecord
{
	defId?: string | undefined;
	label?: string | undefined;
	logicalName: string;
	fetchXml?: string | undefined;
	relations?: Relation[] | undefined;
	valuesMapping?: ValuesMapping | undefined;
	isDeleteObsoleteRecords?: boolean | undefined;
	isUseAlternateKeysForRecord?: boolean | undefined;
	isUseAlternateKeysForLookups?: boolean | undefined;
	isClearInvalidLookups?: boolean | undefined;
	isCreateNewRecords?: boolean | undefined;
	isUpdateExistingRecords?: boolean | undefined;

	constructor(data?: IRecord)
	{
		if (data)
		{
			for (var property in data)
			{
				if (data.hasOwnProperty(property))
					(<any>this)[property] = (<any>data)[property];
			}
		}
	}

	init(data?: any)
	{
		if (data)
		{
			this.defId = data["defId"];
			this.label = data["label"];
			this.logicalName = data["logicalName"];
			this.fetchXml = data["fetchXml"];
			if (data["relations"] && data["relations"].constructor === Array)
			{
				this.relations = [];
				for (let item of data["relations"])
					this.relations.push(Relation.fromJS(item));
			}
			this.valuesMapping = data["valuesMapping"] ? ValuesMapping.fromJS(data["valuesMapping"]) : <any>undefined;
			this.isDeleteObsoleteRecords = data["isDeleteObsoleteRecords"];
			this.isUseAlternateKeysForRecord = data["isUseAlternateKeysForRecord"];
			this.isUseAlternateKeysForLookups = data["isUseAlternateKeysForLookups"];
			this.isClearInvalidLookups = data["isClearInvalidLookups"];
			this.isCreateNewRecords = data["isCreateNewRecords"];
			this.isUpdateExistingRecords = data["isUpdateExistingRecords"];
		}
	}

	static fromJS(data: any): Record
	{
		let result = new Record();
		result.init(data);
		return result;
	}

	toJSON(data?: any)
	{
		data = typeof data === 'object' ? data : {};
		data["defId"] = this.defId;
		data["label"] = this.label;
		data["logicalName"] = this.logicalName;
		data["fetchXml"] = this.fetchXml;
		if (this.relations && this.relations.constructor === Array)
		{
			data["relations"] = [];
			for (let item of this.relations)
				data["relations"].push(item.toJSON());
		}
		data["valuesMapping"] = this.valuesMapping ? this.valuesMapping.toJSON() : <any>undefined;
		data["isDeleteObsoleteRecords"] = this.isDeleteObsoleteRecords;
		data["isUseAlternateKeysForRecord"] = this.isUseAlternateKeysForRecord;
		data["isUseAlternateKeysForLookups"] = this.isUseAlternateKeysForLookups;
		data["isClearInvalidLookups"] = this.isClearInvalidLookups;
		data["isCreateNewRecords"] = this.isCreateNewRecords;
		data["isUpdateExistingRecords"] = this.isUpdateExistingRecords;
		return data;
	}
}

export interface IRecord
{
	defId?: string | undefined;
	label?: string | undefined;
	logicalName: string;
	fetchXml?: string | undefined;
	relations?: Relation[] | undefined;
	valuesMapping?: ValuesMapping | undefined;
	isDeleteObsoleteRecords?: boolean | undefined;
	isUseAlternateKeysForRecord?: boolean | undefined;
	isUseAlternateKeysForLookups?: boolean | undefined;
	isClearInvalidLookups?: boolean | undefined;
	isCreateNewRecords?: boolean | undefined;
	isUpdateExistingRecords?: boolean | undefined;
}

export class Relation implements IRelation
{
	defId?: string | undefined;
	schemaName: string;
	relationType: number;
	isDeleteObsoleteRelations?: boolean | undefined;
	isDisassociateObsoleteRelations?: boolean | undefined;
	entityDefinition: Record = new Record();

	constructor(data?: IRelation)
	{
		if (data)
		{
			for (var property in data)
			{
				if (data.hasOwnProperty(property))
					(<any>this)[property] = (<any>data)[property];
			}
		}
	}

	init(data?: any)
	{
		if (data)
		{
			this.defId = data["defId"];
			this.schemaName = data["schemaName"];
			this.relationType = data["relationType"];
			this.isDeleteObsoleteRelations = data["isDeleteObsoleteRelations"];
			this.isDisassociateObsoleteRelations = data["isDisassociateObsoleteRelations"];
			this.entityDefinition = data["entityDefinition"] ? Record.fromJS(data["entityDefinition"]) : new Record();
		}
	}

	static fromJS(data: any): Relation
	{
		let result = new Relation();
		result.init(data);
		return result;
	}

	toJSON(data?: any)
	{
		data = typeof data === 'object' ? data : {};
		data["defId"] = this.defId;
		data["schemaName"] = this.schemaName;
		data["relationType"] = this.relationType;
		data["isDeleteObsoleteRelations"] = this.isDeleteObsoleteRelations;
		data["isDisassociateObsoleteRelations"] = this.isDisassociateObsoleteRelations;
		data["entityDefinition"] = this.entityDefinition ? this.entityDefinition.toJSON() : <any>undefined;
		return data;
	}
}

export interface IRelation
{
	defId?: string | undefined;
	schemaName: string;
	relationType: number;
	isDeleteObsoleteRelations?: boolean | undefined;
	isDisassociateObsoleteRelations?: boolean | undefined;
	entityDefinition: Record;
}

export class ValueMapping implements IValueMapping
{
	isIgnoreValues?: boolean | undefined;
	sourceField: string;
	sourceFieldType: number;
	sourceValue?: string | undefined;
	destinationField: string;
	destinationFieldType?: number | undefined;
	destinationValue?: string | undefined;

	constructor(data?: IValueMapping)
	{
		if (data)
		{
			for (var property in data)
			{
				if (data.hasOwnProperty(property))
					(<any>this)[property] = (<any>data)[property];
			}
		}
	}

	init(data?: any)
	{
		if (data)
		{
			this.isIgnoreValues = data["isIgnoreValues"];
			this.sourceField = data["sourceField"];
			this.sourceFieldType = data["sourceFieldType"];
			this.sourceValue = data["sourceValue"];
			this.destinationField = data["destinationField"];
			this.destinationFieldType = data["destinationFieldType"];
			this.destinationValue = data["destinationValue"];
		}
	}

	static fromJS(data: any): ValueMapping
	{
		let result = new ValueMapping();
		result.init(data);
		return result;
	}

	toJSON(data?: any)
	{
		data = typeof data === 'object' ? data : {};
		data["isIgnoreValues"] = this.isIgnoreValues;
		data["sourceField"] = this.sourceField;
		data["sourceFieldType"] = this.sourceFieldType;
		data["sourceValue"] = this.sourceValue;
		data["destinationField"] = this.destinationField;
		data["destinationFieldType"] = this.destinationFieldType;
		data["destinationValue"] = this.destinationValue;
		return data;
	}
}

export interface IValueMapping
{
	isIgnoreValues?: boolean | undefined;
	sourceField: string;
	sourceFieldType: number;
	sourceValue?: string | undefined;
	destinationField: string;
	destinationFieldType?: number | undefined;
	destinationValue?: string | undefined;
}

export class Configuration implements IConfiguration
{
	exportOptions?: ExportOptions | undefined;
	importOptions?: ImportOptions | undefined;
	records?: Record[] | undefined;

	constructor(data?: IConfiguration)
	{
		if (data)
		{
			for (var property in data)
			{
				if (data.hasOwnProperty(property))
					(<any>this)[property] = (<any>data)[property];
			}
		}
	}

	init(data?: any)
	{
		if (data)
		{
			this.exportOptions = data["exportOptions"] ? ExportOptions.fromJS(data["exportOptions"]) : <any>undefined;
			this.importOptions = data["importOptions"] ? ImportOptions.fromJS(data["importOptions"]) : <any>undefined;
			if (data["records"] && data["records"].constructor === Array)
			{
				this.records = [];
				for (let item of data["records"])
					this.records.push(Record.fromJS(item));
			}
		}
	}

	static fromJS(data: any): Configuration
	{
		let result = new Configuration();
		result.init(data);
		return result;
	}

	toJSON(data?: any)
	{
		data = typeof data === 'object' ? data : {};
		data["exportOptions"] = this.exportOptions ? this.exportOptions.toJSON() : <any>undefined;
		data["importOptions"] = this.importOptions ? this.importOptions.toJSON() : <any>undefined;
		if (this.records && this.records.constructor === Array)
		{
			data["records"] = [];
			for (let item of this.records)
				data["records"].push(item.toJSON());
		}
		return data;
	}
}

export interface IConfiguration
{
	exportOptions?: ExportOptions | undefined;
	importOptions?: ImportOptions | undefined;
	records?: Record[] | undefined;
}

export class ValuesMapping implements IValuesMapping
{
	targetEntityName?: string | undefined;
	valueMappings: ValueMapping[] = [];

	constructor(data?: IValuesMapping)
	{
		if (data)
		{
			for (var property in data)
			{
				if (data.hasOwnProperty(property))
					(<any>this)[property] = (<any>data)[property];
			}
		}
	}

	init(data?: any)
	{
		if (data)
		{
			this.targetEntityName = data["targetEntityName"];
			if (data["valueMappings"] && data["valueMappings"].constructor === Array)
			{
				this.valueMappings = [];
				for (let item of data["valueMappings"])
					this.valueMappings.push(ValueMapping.fromJS(item));
			}
		}
	}

	static fromJS(data: any): ValuesMapping
	{
		let result = new ValuesMapping();
		result.init(data);
		return result;
	}

	toJSON(data?: any)
	{
		data = typeof data === 'object' ? data : {};
		data["targetEntityName"] = this.targetEntityName;
		if (this.valueMappings && this.valueMappings.constructor === Array)
		{
			data["valueMappings"] = [];
			for (let item of this.valueMappings)
				data["valueMappings"].push(item.toJSON());
		}
		return data;
	}
}

export interface IValuesMapping
{
	targetEntityName?: string | undefined;
	valueMappings: ValueMapping[];
}

export class ExportOptions implements IExportOptions
{
	isExcludeOwner?: boolean | undefined;
	isCompressData?: boolean | undefined;

	constructor(data?: IExportOptions)
	{
		if (data)
		{
			for (var property in data)
			{
				if (data.hasOwnProperty(property))
					(<any>this)[property] = (<any>data)[property];
			}
		}
	}

	init(data?: any)
	{
		if (data)
		{
			this.isExcludeOwner = data["isExcludeOwner"];
			this.isCompressData = data["isCompressData"];
		}
	}

	static fromJS(data: any): ExportOptions
	{
		let result = new ExportOptions();
		result.init(data);
		return result;
	}

	toJSON(data?: any)
	{
		data = typeof data === 'object' ? data : {};
		data["isExcludeOwner"] = this.isExcludeOwner;
		data["isCompressData"] = this.isCompressData;
		return data;
	}
}

export interface IExportOptions
{
	isExcludeOwner?: boolean | undefined;
	isCompressData?: boolean | undefined;
}

export class ImportOptions implements IImportOptions
{
	bulkSize?: number | undefined;

	constructor(data?: IImportOptions)
	{
		if (data)
		{
			for (var property in data)
			{
				if (data.hasOwnProperty(property))
					(<any>this)[property] = (<any>data)[property];
			}
		}
	}

	init(data?: any)
	{
		if (data)
		{
			this.bulkSize = data["bulkSize"];
		}
	}

	static fromJS(data: any): ImportOptions
	{
		let result = new ImportOptions();
		result.init(data);
		return result;
	}

	toJSON(data?: any)
	{
		data = typeof data === 'object' ? data : {};
		data["bulkSize"] = this.bulkSize;
		return data;
	}
}

export interface IImportOptions
{
	bulkSize?: number | undefined;
}
